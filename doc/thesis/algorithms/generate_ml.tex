\SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{\}}%
% \SetKwProg{Fn}{dsadsadas}{dsadad}
% \SetKwFunction{FRecurs}{generate\_multilayer}%
\SetKwFor{For}{for }{ \textbf{do}}{}{}%
\SetKwFor{ForEach}{foreach }{ \textbf{do}}{}{}%
\SetKwFor{If}{if }{ \textbf{then}}{}{}%
\SetKwFor{While}{while }{ \textbf{do}}{}{}%
% \SetKwIF{If}{ElseIf}{Else}{if}{\{}{elif}{else\{}{}%
% \SetKwFor{While}{while}{\{}{}%
% \SetKwRepeat{Repeat}{repeat\{}{until}%
% \AlgoDisplayBlockMarkers
% \SetAlgoNoLine%
\begin{algorithm}   
    \caption{Generazione multilayer network}
    \label{alg:generate}
% \Fn{\FRecurs{asd}}
    % {
    \SetKwData{Left}{left}
    \SetKwData{This}{this}
    \SetKwData{Up}{up}
    \SetKwFunction{Union}{Union}
    \SetKwFunction{FindCompress}{FindCompress}
    
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetStartEndCondition{ }{}{}%
    \DontPrintSemicolon
    \Input{
        \textsc{Graph} $\mathit{layers}$\abracks \algcmnt{grafi usati come layers} \\ 
        \tint\ $\mathit{perm\_l}$\abracks \algcmnt{posizione di ogni layer nella permutazione}\\
        \tint\ $\mathit{perm\_n}$\abracks \abracks \algcmnt{posizione di un nodo nella permutazione di ogni layer}\\
        \tint\ $\mathit{d}$\\
        \tfloat\ $\mathit{s\_degree}$ \\
        \tfloat\ $\mathit{s\_layer}$ \\
        \tfloat\ $\mathit{s\_node}$ \\
    }
    
    \tint\ $\mathit{total\_nodes} = 0$\;
    \For{$i = 0$ \KwTo $\mathit{layers}.\mathit{size()}$} {
            $\mathit{total\_nodes} = \mathit{total\_nodes} + \mathit{layers}[i].\mathit{nodes()}.\mathit{size()}$\;
    }
    \tint\ $\mathit{max\_interconnections} = \mathit{d} \cdot \lfloor\log_{2}{(\mathit{total\_nodes})}\rfloor$\;
    \BlankLine
    
    \tcp{I due parametri della classe \textsc{ZipfGenerator} regolano rispettivamente \\
    il massimo della distribuzione e il grado di asimmetria}
    \tzgen\ $\mathit{degree\_generator}(\mathit{max\_interconnections}, \mathit{s\_degree})$\;
    \tzgen\ $\mathit{layer\_generator}(\mathit{layers.size()}, \mathit{s\_layer})$\;
    \tzgen\ $\mathit{node\_generators}[0\dots \mathit{layers}.\mathit{size}() - 1]$\;
    \For{$l = 0$ \KwTo $\mathit{layers}.\mathit{size}() - 1$}{
        $\mathit{node\_generators}[l] = $ \tzgen $(\mathit{layers}[l].\mathit{size}(), \mathit{s\_degree})$\;
    }
    \BlankLine

    \textsc{MultilayerNetwork} $m$\;


    \For {$l = 0$ \KwTo $\mathit{layers}.\mathit{size}() - 1$}{
        \ForEach {$n \in \mathit{layers}[l]$ }{
            \tcp*{intra-connessioni}
            \For {$v \in \mathit{layers}[l].\mathit{adj}(n)$}{
                $m.\mathit{add\_edge}(n, l, v, l)$\;
            }
            \tcp*{inter-connessioni tra un nodo e le sue controparti negli altri layer}
            \For {$j = 0$ \KwTo $\mathit{layers}.\mathit{size}() - 1$}{ 
                \If {$ j \neq l$ \textup{\textbf{and}} $n \in \mathit{layers}[j].\mathit{nodes}()$} {
                    $m.\mathit{add\_edge}(n, l, n, j)$\;
                }
            }
            \tcp*{Generazione inter-connessioni casuali}
            \tint\ $\mathit{degree} = \mathit{degree\_generator}.\mathit{next}()$\;
            \For {$i = 1$ \KwTo $\mathit{degree}$}{
                \tbool\ $\mathit{added} = \False$\;
                \While{\textup{\textbf{not}} $\mathit{added}$}{
                    \tint\ $\mathit{l\_dest} = \mathit{l\_index}[\mathit{layer\_generator}.\mathit{next}()]$\;
                    \While {$\mathit{l\_dest} == l$} {
                        $\mathit{l\_dest} = \mathit{l\_index}[\mathit{layer\_generator}.\mathit{next}()]$\;
                    }
                    \tint\ $\mathit{n\_dest}= \mathit{n\_index}[\mathit{l\_dest}][\mathit{node\_generators}[\mathit{l\_dest}].\mathit{next}()]$\;
                    \If{\textup{\textbf{not}} $m.\mathit{has\_edge}(n, l, \mathit{n\_dest}, \mathit{l\_dest})$}{
                        $\mathit{added} = \True$\;
                        $m.\mathit{add\_edge}(n, l, \mathit{n\_dest}, \mathit{l\_dest})$\;
                    }
                }
            }
        }
    }
\end{algorithm}