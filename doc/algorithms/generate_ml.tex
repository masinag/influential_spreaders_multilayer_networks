\SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{\}}%
% \SetKwProg{Fn}{dsadsadas}{dsadad}
% \SetKwFunction{FRecurs}{generate\_multilayer}%
\SetKwFor{For}{for }{ \textbf{do}}{}{}%
\SetKwFor{If}{if }{ \textbf{then}}{}{}%
\SetKwFor{While}{while }{ \textbf{do}}{}{}%
% \SetKwIF{If}{ElseIf}{Else}{if}{\{}{elif}{else\{}{}%
% \SetKwFor{While}{while}{\{}{}%
% \SetKwRepeat{Repeat}{repeat\{}{until}%
% \AlgoDisplayBlockMarkers
% \SetAlgoNoLine%
\begin{algorithm}   
    \caption{Generazione multilayer networks}
    \label{alg:generate}
% \Fn{\FRecurs{asd}}
    % {
    \SetKwData{Left}{left}
    \SetKwData{This}{this}
    \SetKwData{Up}{up}
    \SetKwFunction{Union}{Union}
    \SetKwFunction{FindCompress}{FindCompress}
    
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetStartEndCondition{ }{}{}%
    \DontPrintSemicolon
    \Input{
        \textsc{Graph} $layers$\abracks \algcmnt{grafi usati come layers} \\ 
        \tint\ $perm\_l$\abracks \algcmnt{posizione di ogni layer nella permutazione}\\
        \tint\ $perm\_n$\abracks \abracks \algcmnt{posizione di un nodo nella permutazione di ogni layer}\\
        \tint\ $d $\\
        \tfloat\ $s\_degree$ \\
        \tfloat\ $s\_layer$ \\
        \tfloat\ $s\_node$ \\
    }
    
    \tint\ $total\_nodes = 0$\;
    \For{$i = 0$ \KwTo $layers.size()$} {
            $total\_nodes = total\_nodes + layers[i].nodes().size()$\;
    }
    \tint\ $max\_interconnections = d \cdot \lfloor\log_{2}{(total\_nodes)}\rfloor$\;
    \BlankLine
    
    \tcp{I due parametri della classe \textsc{ZipfGenerator} regolano rispettivamente \\
    il massimo della distribuzione e il grado di asimmetria}
    \tzgen\ $degree\_generator(max\_interconnections, s\_degree)$\;
    \tzgen\ $layer\_generator(layers.size(), s\_layer)$\;
    \tzgen\ $node\_generators[0\dots layers.size() - 1]$\;
    \For{$l = 0$ \KwTo $layers.size() - 1$}{
        $node\_generators[l] = $ \tzgen $(layers[l].size(), s\_degree)$\;
    }
    \BlankLine

    \textsc{MultilayerNetwork} $m$\;


    \For {$l = 0$ \KwTo $layers.size() - 1$}{
        \ForEach {$n \in layers[l]$}{
            \tcp*{intra-connessioni}
            \For {$v \in layers[l].adj(n)$}{
                $m.add\_edge(n, l, v, l)$\;
            }
            \tcp*{inter-connessioni tra un nodo e le sue controparti negli altri layer}
            \For {$j = 0$ \KwTo $layers.size() - 1$}{ 
                \If {$ j \neq l$ \textup{\textbf{and}} $n \in layers[j].nodes()$} {
                    $m.add\_edge(n, l, n, j)$\;
                }
            }
            \tcp*{Generazione inter-connessioni casuali}
            \tint\ $degree = degree\_generator.next()$\;
            \For {$i = 1$ \KwTo $degree$}{
                \tbool\ $added = \False$\;
                \While{\textup{\textbf{not}} $added$}{
                    \tint\ $l\_dest = l\_index[layer\_generator.next()]$\;
                    \While {$l\_dest == l$} {
                        $l\_dest = l\_index[layer\_generator.next()]$\;
                    }
                    \tint\ $n\_dest= n\_index[l\_dest][node\_generators[l\_dest].next()]$\;
                    \If{\textup{\textbf{not}} $m.has\_edge(n, l, n\_dest, l\_dest)$}{
                        $added = \True$\;
                        $m.add\_edge(n, l, n\_dest, l\_dest)$\;
                    }
                }
            }
        }
    }
\end{algorithm}